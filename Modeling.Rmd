---
title: "Scoring"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Library pour modélisation
```{r}
library(xgboost)
install.packages("plotROC")
library(plotROC)
```

Création d'une variable année pour faire notre cross validation
On retire toutes les variables quali
```{r}
load("Data/table_score.RData")
table_score_sauv<-table_score
#Création de l'annee
Annee<-substr(as.character(table_score$tourney_date),1,4)
#Séparation des variables quali et des variables quanti
columns_type <- sapply(table_score, class)
table(columns_type)
table_score_df<-as.data.frame(table_score)
table_score<-table_score_df[,columns_type != "character"]
table_score_char<-table_score_df[,columns_type == "character"]
table_score_char<-cbind(table_score_char,table_score$tourney_date,Annee)
head(table_score_char)
table_score$tourney_date<-NULL
columns_type_df <- sapply(table_score, class)
table(columns_type_df)
table_score<-as.data.table(table_score)
table_score<-cbind(table_score,Annee)
table(table_score$Annee)

```
Paramètres de la boucle AnneeDeb est la première année sur laquelle 
on veut faire de la prédiction de l AnneeDeb à l AnneeFin, en regardant 4
ans dans le passé.
Le paramètre RES est à regler en fonction des modèles appliqués
## Including Plots

Preparation des paramètres ante-modèlisation (RES est à modifier selon les modèles utilisés)
```{r}
AnneeDeb<-2010
AnneeFin<-2018
passee<-3
RES<- data.frame(Y=table_score$coin,Annee=table_score$Annee,XGboots=0,
                 SVM=0,Reseau=0,XGboots2=0,SVM2=0,Reseau2=0)

```

Modélisation en boucle
train <- data.frame(churn_x, churn_y)

model_glmnet <- train(churn_y ~ ., data = train,
  metric = "ROC",
  method = "glmnet",
  trControl = myControl
)
Basé sur le code de j'ai oublié son nom, le paramètrage du modèle et les modèles sont à changer. Je suis parti sur une table de matrice comme pour l'exemple avec les reg log sous contraintes, à changer aussi selon besoin
```{r}
library(glmnet)
library(randomForest)
for(i in AnneeDeb:AnneeFin){
  i=2010
  XXA <- as.matrix(table_score[Annee<i & Annee>i-(passee+1)]
                   [,Annee:=NULL][,coin:=NULL]
 )
  YYA <- as.matrix(table_score[Annee<i & Annee>i-(passee+1),c("coin")])
  mod <- glmnet(XXA,YYA,lambda=0,family="binomial",alpha=0)
  RES[Annee==i,"XGboots"]<-predict(mod,                          newx=as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
  mod <- glmnet(XXA,YYA,lambda=2,alpha=0)
  RES[Annee==i,"SVM"] <- predict(mod,newx=as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
  mod <- glmnet(XXA,YYA,lambda=10,alpha=0)
  RES[Annee==i,"Reseau"] <- predict(mod,newx=as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
  mod <- xgboost(data = )
  RES[Annee==i,"XGboots2"] <- predict(mod,newx=as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
  mod <- randomForest(XXA,YYA)
  RES[Annee==i,"SVM2"] <- predict(mod,as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
  mod <- randomForest(XXA,YYA,ntree=100)
  RES[Annee==i,"Reseau2"] <- predict(mod,as.matrix(table_score[Annee==i,][,Annee:=NULL][,coin:=NULL]))
}
```

Modélisation propres au XGBosst
1) eta optimal en premier lieu 0.5 (0.1 0.05 0.2)
2)max.depth optimal 25
3) eta optimal en second lieu 0.5
```{r}
modeles<-vector("list",AnneeFin-AnneeDeb)
modeles1<-modeles
modeles2<-modeles
modeles3<-modeles
Resultats<-c(rep(0,AnneeFin-AnneeDeb+1))
Resultats1<-Resultats
Resultats2<-Resultats
Resultats3<-Resultats
func<- function(x){
  ifelse(x<0.50,0,1)
}

for(i in AnneeDeb:AnneeFin){
  train<-table_score[Annee<i & Annee>i-(passee+1)][,Annee:=NULL]
  target<-train$coin
  train$coin<-NULL
  test<-table_score[Annee==i][,Annee:=NULL]
  res_test<-test$coin
  
  xgboost_mod<- xgboost(data=data.matrix(train),label = target, max.depth=25, eta=0.5, nrounds=15,objective="binary:logistic")
  modeles[[i-AnneeDeb+1]]<-xgboost_mod
  y_pred<-predict(xgboost_mod,data.matrix(test))
  y_pred2<-lapply(y_pred,FUN = func)
  Resultats[i-AnneeDeb+1]<-sum(as.numeric(y_pred2==res_test))/length(y_pred2)
  
   xgboost_mod1<- xgboost(data=data.matrix(train),label = target, max.depth=25, eta=0.75, nthread=2, nrounds=15,objective="binary:logistic")
  modeles1[[i-AnneeDeb+1]]<-xgboost_mod
  y_pred<-predict(xgboost_mod1,data.matrix(test))
  y_pred2<-lapply(y_pred,FUN = func)
  Resultats1[i-AnneeDeb+1]<-sum(as.numeric(y_pred2==res_test))/length(y_pred2)

   xgboost_mod2<- xgboost(data=data.matrix(train),label = target, max.depth=25, eta=1, nthread=2,nrounds=15,objective="binary:logistic")
  modeles2[[i-AnneeDeb+1]]<-xgboost_mod
  y_pred<-predict(xgboost_mod2,data.matrix(test))
  y_pred2<-lapply(y_pred,FUN = func)
  Resultats2[i-AnneeDeb+1]<-sum(as.numeric(y_pred2==res_test))/length(y_pred2)
  
  
   xgboost_mod3<- xgboost(data=data.matrix(train),label = target, max.depth=25, eta=1.25, nthread=2,nrounds=15,objective="binary:logistic")
  modeles3[[i-AnneeDeb+1]]<-xgboost_mod
  y_pred<-predict(xgboost_mod3,data.matrix(test))
  y_pred2<-lapply(y_pred,FUN = func)
  Resultats3[i-AnneeDeb+1]<-sum(as.numeric(y_pred2==res_test))/length(y_pred2)

}
summary(Resultats)
summary(Resultats1)
summary(Resultats2)
summary(Resultats3)

#To do 
#étude des modèles voir variables pertinentes
#resau de neuronnes 

```
Etudes sur le nombres d'année optimal àprendre en compte pour modeliser :
4 5 6 
12 11 14
```{r}
modeles<-vector("list",15)
Resultats<-c(rep(0,15))
func<- function(x){
  ifelse(x<0.50,0,1)
}
AN=2018
for(i in 1:15){
  train<-table_score[Annee<AN & Annee>AN-(i+1)][,Annee:=NULL]
  target<-train$coin
  train$coin<-NULL
  test<-table_score[Annee==AN][,Annee:=NULL]
  res_test<-test$coin
  
  xgboost_mod<- xgboost(data=data.matrix(train),label = target, max.depth=25, eta=0.5, nrounds=15,objective="binary:logistic")
  modeles[[i]]<-xgboost_mod
  y_pred<-predict(xgboost_mod,data.matrix(test))
  y_pred2<-lapply(y_pred,FUN = func)
  y_pred3<-unlist(y_pred2)
  Resultats[i]<-sum(as.numeric(y_pred3==res_test))/length(y_pred2)
  

}
summary(Resultats)
which.max(Resultats)
#ETUDE DU MODELE OPTIMAL 
model<-xgb.dump(modeles[[which.max(Resultats)]],with_stats = T)
model[1:10]
names<-dimnames(data.matrix(train))[[2]]
importance<-xgb.importance(names,modeles[[which.max(Resultats)]])
importance
xgb.plot.importance(importance[,])

model<-xgb.dump(modeles[[which.min(Resultats)]],with_stats = T)
model[1:10]
names<-dimnames(data.matrix(train))[[2]]
importance<-xgb.importance(names,modeles[[which.max(Resultats)]])
importance
xgb.plot.importance(importance[,])

#Etude des predictions
check<-table_score[Annee==2018]
check<-cbind(check,y_pred3)
prop.table(table(check$y_pred3==check$coin))
```

